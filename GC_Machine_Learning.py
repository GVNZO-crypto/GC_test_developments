# Пример машинного обучения 

# Для работы с машинным обучение нужна библиотека TensorFlow и NymPy
# Команды для установки NymPy:
# pip install numpy

# Обновление до последней версии
# pip install --upgrade pip
# Проверка совместимости CPU и GPU:
# pip install tensorflow

# Начните с импорта. Здесь вы импортируете TensorFlow и вызываете его для простоты использования.tf
# Затем импортируйте библиотеку под названием , которая легко и быстро представляет ваши данные в виде списков.numpy
# Структура для определения нейронной сети как набора последовательных слоев называется , поэтому импортируйте и ее.keras

import tensorflow as tf
import numpy as np
from tensorflow import keras

# Определите и составьте нейронную сеть
# Далее создайте самую простую из возможных нейронных сетей. Она имеет один слой, этот слой имеет один нейрон,
# и входной формой для нее является только одно значение.

model = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])])

# Далее напишите код для компиляции вашей нейронной сети. При этом вам нужно указать две функции-a и .lossoptimizer.
# В этом примере вы знаете, что связь между числами равна Y=3X+1.
# Когда компьютер пытается узнать это, он делает предположение, возможно,
# Y=10X+10. Функция сравнивает угаданные ответы с известными правильными ответами и определяет, насколько хорошо или плохо она справилась с задачей.
# Далее модель использует эту функцию, чтобы сделать еще одно предположение.
# Основываясь на результате функции потерь, она пытается минимизировать потери.
# На этом этапе, возможно, получится что-то вроде Y=5X+5. Хотя это все еще довольно плохо, это ближе к правильному результату (потери меньше).optimizer
# Модель повторяет это для количества эпох, что вы увидите в ближайшее время
# Во-первых, вот как указать ей использовать для потери и стохастический градиентный спуск () для оптимизатора. 
# Вам пока не нужно понимать математику, но вы можете видеть, что они работают !mean_squared_errorsgd
# Со временем вы научитесь использовать различные и подходящие функции потерь и оптимизатора для различных сценариев.

model.compile(optimizer='sgd', loss='mean_squared_error')

# Предоставьте данные
# Далее, предоставьте некоторые данные. В данном случае вы берете шесть переменных X и шесть переменных Y. 
# Вы можете увидеть, что связь между ними такова: Y=3X+1, поэтому там, где X равен -1, Y равен -2.
# Библиотека python под названием NumPy предоставляет множество структур данных типа массива для этого. 
# Задайте значения в виде массива в NumPy с помощью .np.array[]

xs = np.array([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0], dtype=float)
ys = np.array([-2.0, 1.0, 4.0, 7.0, 10.0, 13.0], dtype=float)

# Теперь у вас есть весь код, необходимый для определения нейронной сети. 
# Следующим шагом будет ее обучение, чтобы проверить, сможет ли она вывести закономерности между этими числами и использовать их для создания модели.

# Процесс обучения нейронной сети, когда она изучает взаимосвязь между X и Y, находится в вызове. 
# Именно здесь нейронная сеть проходит через цикл, прежде чем сделать предположение, измерить, насколько оно хорошее или плохое (потери),
# или использовать оптимизатор, чтобы сделать другое предположение. Он будет делать это в течение заданного вами количества эпох. 
# Когда вы запустите этот код, вы увидите, что потери будут выведены для каждой эпохи.model.fit

model.fit(xs, ys, epochs=500)
# Например, вы можете видеть, что для первых нескольких эпох значение потерь довольно велико, но с каждым шагом оно становится все меньше.
# По мере обучения потери вскоре становятся очень незначительными.
# К моменту окончания обучения потери чрезвычайно малы, что свидетельствует о том, что наша модель отлично справляется с задачей вывода взаимосвязи между числами.
# Возможно, вам не понадобятся все 500 эпох, и вы можете поэкспериментировать с разными количествами. 
# Как видно из примера, потери очень малы после всего 50 эпох, так что этого может быть достаточно!

# У вас есть модель, которая была обучена для изучения взаимосвязи между X и Y. Вы можете использовать этот метод, чтобы она вычислила Y для ранее неизвестного X.
#  Например, если X равен 10, как вы думаете, каким будет Y? Сделайте предположение, прежде чем выполнить следующий код:model.predict

print(model.predict([10.0]))

# Вы могли подумать, что 31, но в итоге оказалось, что больше. Почему вы так думаете?
# Нейронные сети работают с вероятностями, поэтому они вычислили, что существует очень высокая вероятность того, что связь между X и Y равна Y=3X+1, 
# но они не могут знать наверняка, имея только шесть точек данных. Результат очень близок к 31, но не обязательно 31.
# Когда вы будете работать с нейронными сетями, вы увидите, что эта схема повторяется. Вы почти всегда будете иметь дело с вероятностями, а не с уверенностью, 
# и будете немного кодировать, чтобы определить результат на основе вероятностей, особенно когда речь идет о классификации.

# Хотите верьте, хотите нет, но вы изучили большинство концепций в ML, которые вы будете использовать в гораздо более сложных сценариях. 
# Вы узнали, как обучить нейронную сеть выявлять взаимосвязь между двумя наборами чисел, определив сеть. 
# Вы определили набор слоев (в данном случае только один), содержащих нейроны (также всего
# Набор из сети, функции потерь и оптимизатора обрабатывает процесс угадывания взаимосвязи между числами, измеряет, 
# насколько хорошо это получилось, а затем генерирует новые параметры для новых угадываний.

# coding_by_GVNZO